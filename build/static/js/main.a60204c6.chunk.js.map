{"version":3,"sources":["mazeAlgorithms/recursive.js","algorithms/dijkstra.js","algorithms/greedyBestFirstSearch.js","Visualizer/visualizer.jsx","App.js","GitHub-Mark-64px.png","reportWebVitals.js","index.js"],"names":["walls","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","col","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","prevNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","greedyBFS","a","b","totalDistance","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","Math","abs","getNodesInShortestPathOrderGreedyBFS","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","canvas","ctx","resolution","width","getWidth","height","getHeight","START_NODE_COL","START_NODE_ROW","FINISH_NODE_COL","FINISH_NODE_ROW","timeouts","speed","lastFrameTime","lastMousePos","x","y","mouseStillPressed","rects","howManyCells","less","window","innerWidth","innerHeight","roundNode","radius","gradient","this","color","time","frame","clearRect","fillStyle","colourAt","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","Visualizer","props","resize","forceUpdate","fullReset","state","mouseIsPressed","isDraggingStart","isDraggingFinish","removeEventListener","setState","getInitialGrid","createGrid","addEventListener","algorithm","document","getElementById","getContext","createPartGrid","drawCube","drawLine","requestAnimationFrame","draw","bind","deltaTime","strokeStyle","event","rect","getBoundingClientRect","clientX","left","clientY","top","pos","getCursorPositionInPixels","e","busy","cursPos","getCursorPositionInGrid","isStart","isFinish","moveStartOrFinish","calculateWall","instant","clearVisualization","setTimeout","shortPath","Rainbow","setSpectrum","setNumberRange","animateAlgorithm","visualizeDijkstra","visualizeGreedyBFS","start","drawStartOrFinish","newGrid","drawWall","resetWalls","maze","mazeElement","redrawStartAndFinish","xd","yd","stroke","fillRect","widthIn","round","heightIn","skipBusyCheck","clearTimeout","FormControl","variant","sx","m","minWidth","InputLabel","id","Select","defaultValue","style","textAlign","onChange","target","value","MenuItem","className","labelId","label","ButtonGroup","Button","onClick","visualize","transform","visualizeMaze","onMouseDown","handleMouseDown","onMouseMove","handleMouseMove","onMouseUp","handleMouseUp","Component","createNode","currentRow","App","href","src","alt","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a60204c6.chunk.js","sourcesContent":["let walls;\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let vertical = range(grid.length);\r\n    let horizontal = range(grid[0].length);\r\n    walls = [];\r\n    getRecursiveWalls(vertical, horizontal, startNode, finishNode);\r\n    return walls;\r\n}\r\n\r\nfunction range(len) {\r\n    let result = [];\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, startNode, finishNode) {\r\n    if (vertical.length < 2 || horizontal.length < 2) {\r\n        return;\r\n    }\r\n    let dir;\r\n    let num;\r\n    if (vertical.length > horizontal.length) {\r\n        dir = 0;\r\n        num = generateOddRandomNumber(vertical);\r\n    }\r\n    if (vertical.length <= horizontal.length) {\r\n        dir = 1;\r\n        num = generateOddRandomNumber(horizontal);\r\n    }\r\n\r\n    if (dir === 0) {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical.slice(0, vertical.indexOf(num)),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical.slice(vertical.indexOf(num) + 1),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n    } else {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(0, horizontal.indexOf(num)),\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(horizontal.indexOf(num) + 1),\r\n            startNode,\r\n            finishNode\r\n        );\r\n    }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n    let max = array.length - 1;\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 === 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n    if (dir === 0) {\r\n        if (horizontal.length === 2) return;\r\n        for (let temp of horizontal) {\r\n            if (\r\n                (temp === startNode.row && num === startNode.col) ||\r\n                (num === finishNode.row && temp === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([temp, num]);\r\n        }\r\n    } else {\r\n        if (vertical.length === 2) return;\r\n        for (let temp of vertical) {\r\n            if (\r\n                (num === startNode.row && temp === startNode.col) ||\r\n                (temp === finishNode.row && num === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([num, temp]);\r\n        }\r\n    }\r\n    if (!isStartFinish) {\r\n        tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n    }\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall);\r\n    }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 !== 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return randomNum;\r\n}","\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if (closestNode.row === finishNode.row && closestNode.col === finishNode.col) return visitedNodesInOrder;\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.prevNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);// 0 -1\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // 0 1\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);// -1 0\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // 1 0\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","export function greedyBFS(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let unvisitedNodes = []; //open list\r\n    let visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    unvisitedNodes.push(startNode);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n        let neighbours = getNeighbours(closestNode, grid);\r\n        for (let neighbour of neighbours) {\r\n            let distance = closestNode.distance + 1;\r\n            //f(n) = h(n)\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n                unvisitedNodes.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            } else if (distance < neighbour.distance) {\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    let neighbours = [];\r\n    let { col, row } = node;\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n    return neighbours.filter((neighbour) => !neighbour.isWall && !neighbour.isVisited);\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n    let x = Math.abs(node.row - finishNode.row);\r\n    let y = Math.abs(node.col - finishNode.col);\r\n    return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n    for (let node of unvisitedNodes) {\r\n        if (node.row === neighbour.row && node.col === neighbour.col) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","import React, {Component} from 'react';\r\nimport \"./visualizer.css\"\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra'\r\nimport {greedyBFS, getNodesInShortestPathOrderGreedyBFS} from '../algorithms/greedyBestFirstSearch'\r\nimport {recursiveDivisionMaze} from '../mazeAlgorithms/recursive'\r\nimport 'rc-slider/assets/index.css';\r\nimport Rainbow from 'rainbowvis.js'\r\nimport {ButtonGroup, Button, Select, MenuItem, InputLabel, FormControl} from \"@mui/material\";\r\n\r\nconst resolution = 29\r\nlet width = getWidth()\r\nlet height =  getHeight()\r\n\r\nlet START_NODE_COL = 5;\r\nlet START_NODE_ROW = 5;\r\n\r\nlet FINISH_NODE_COL = 20\r\nlet FINISH_NODE_ROW = 5;\r\n\r\n// the setTimeouts that are currently waiting\r\nlet timeouts = [];\r\n\r\nlet canvas;\r\nlet ctx;\r\n\r\nlet speed = 5;\r\n\r\nconst FRAMES_PER_SECOND = 60;  // Valid values are 60,30,20,15,10...\r\n// set the mim time to render the next frame\r\nconst FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;\r\nlet lastFrameTime = 0;  // the last frame time\r\n\r\nlet lastMousePos = {x:0,y:0}\r\n\r\nlet mouseStillPressed = false;\r\n\r\nlet rects = [];\r\n\r\nfunction getWidth() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerWidth/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nfunction getHeight() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerHeight*0.85/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nclass roundNode {\r\n    constructor(x, y, width, height, radius, gradient) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.radius = radius;\r\n        this.color = \"Black\";\r\n        this.time = 0;\r\n        this.gradient = gradient;\r\n    }\r\n\r\n    draw(time) {\r\n        this.time += time;\r\n\r\n        this.frame = Math.floor(this.time)/847\r\n\r\n        // if(this.gradient === undefined) {\r\n        //     this.color = \"Yellow\";\r\n        // } else {\r\n        //     this.color = \"Blue\"\r\n        // }\r\n\r\n        ctx.clearRect(this.x, this.y, this.width, this.height);\r\n\r\n        ctx.fillStyle = \"#\"+this.gradient.colourAt(this.frame)\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.x + this.radius, this.y);\r\n        ctx.lineTo(this.x + this.width - this.radius, this.y);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + this.radius);\r\n        ctx.lineTo(this.x + this.width, this.y + this.height - this.radius);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - this.radius, this.y + this.height);\r\n        ctx.lineTo(this.x + this.radius, this.y + this.height);\r\n        ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - this.radius);\r\n        ctx.lineTo(this.x, this.y + this.radius);\r\n        ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);\r\n        ctx.closePath();\r\n        ctx.fill()\r\n\r\n\r\n        if(this.radius > 0) {\r\n            this.radius -= 0.56\r\n        } else {\r\n            rects.splice(rects.indexOf(this), 1);\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Visualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            isDraggingStart: false,\r\n            isDraggingFinish: false,\r\n        };\r\n    }\r\n\r\n    resize = () =>  {\r\n        width = getWidth();\r\n        height = getHeight();\r\n        this.forceUpdate()\r\n        this.fullReset()\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.resize)\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.setState({ grid: getInitialGrid() });\r\n        this.createGrid();\r\n        window.addEventListener('resize', this.resize)\r\n        this.algorithm = 0;\r\n    }\r\n\r\n    //#region grid\r\n\r\n    createGrid() {\r\n        canvas = document.getElementById('canvas');\r\n        ctx = canvas.getContext('2d')\r\n\r\n        canvas.width = width\r\n        canvas.height = height\r\n\r\n        for (let y = 0; y < canvas.height; y+= resolution) {\r\n            for (let x = 0; x < canvas.width; x+= resolution) {\r\n                this.createPartGrid(x,y)\r\n                if(x/resolution === START_NODE_COL && y/resolution === START_NODE_ROW) {\r\n                    ctx.fillStyle = 'Green'\r\n                    this.drawCube(x/resolution,y/resolution)\r\n                }\r\n                if(x/resolution === FINISH_NODE_COL && y/resolution === FINISH_NODE_ROW) {\r\n                    ctx.fillStyle = 'Red'\r\n                    this.drawCube(x/resolution,y/resolution)\r\n                }\r\n            }\r\n        }\r\n        this.drawLine(0,canvas.height,canvas.width,canvas.height)\r\n        this.drawLine(canvas.width,0,canvas.width,canvas.height)\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    draw(time) {\r\n        const deltaTime = time - lastFrameTime\r\n        if(deltaTime < FRAME_MIN_TIME) {\r\n            window.requestAnimationFrame(this.draw.bind(this));\r\n            return;\r\n        }\r\n        lastFrameTime = time;\r\n        for (const rect of rects) {\r\n            rect.draw(deltaTime)\r\n        }\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    createPartGrid(x,y) {\r\n        ctx.strokeStyle = 'Black'\r\n        this.drawLine(x,y, x, y+resolution)\r\n        this.drawLine(x,y, x+resolution, y)\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region mouse\r\n    getCursorPositionInPixels(event) {\r\n        const rect = canvas.getBoundingClientRect()\r\n        const x = event.clientX - rect.left\r\n        const y = event.clientY - rect.top\r\n        return {x: x, y: y}\r\n    }\r\n\r\n    getCursorPositionInGrid(event) {\r\n        const pos = this.getCursorPositionInPixels(event)\r\n        return {x: Math.floor(pos.x/resolution), y: Math.floor(pos.y/resolution)}\r\n    }\r\n\r\n    handleMouseDown(e) {\r\n        if(this.busy) return;\r\n\r\n        const cursPos = this.getCursorPositionInGrid(e)\r\n        const {grid} = this.state;\r\n        if(grid[cursPos.y][cursPos.x].isStart) {\r\n            this.setState({isDraggingStart: true})\r\n        } else if(grid[cursPos.y][cursPos.x].isFinish) {\r\n            this.setState({isDraggingFinish: true})\r\n        }\r\n\r\n        this.setState({mouseIsPressed: true});\r\n        mouseStillPressed = true;\r\n    }\r\n\r\n    handleMouseMove(e) {\r\n        if(this.busy) return;\r\n\r\n        // console.log(this.getCursorPosition(e).x + \" | \" + this.getCursorPosition(e).y)\r\n        const pos = this.getCursorPositionInGrid(e);\r\n        if (!this.state.mouseIsPressed) return;\r\n        if(this.state.isDraggingStart) {\r\n            this.moveStartOrFinish(pos.x,pos.y, true)\r\n        } else if(this.state.isDraggingFinish) {\r\n            this.moveStartOrFinish(pos.x,pos.y,false)\r\n        } else {\r\n            this.calculateWall(e);\r\n        }\r\n        mouseStillPressed = false;\r\n    }\r\n\r\n    handleMouseUp(e) {\r\n        if(this.busy) return;\r\n\r\n        this.setState({mouseIsPressed: false, isDraggingStart: false, isDraggingFinish: false});\r\n        if(mouseStillPressed && !this.state.isDraggingStart && !this.state.isDraggingFinish) {\r\n            lastMousePos.x++;\r\n            this.calculateWall(e);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region dijkstra visual\r\n\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, instant = false) {\r\n        this.clearVisualization(true);\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if(i===0) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                if(i === visitedNodesInOrder.length-1) {\r\n                    this.shortPath(nodesInShortestPathOrder, instant);\r\n                } else {\r\n                    const node = visitedNodesInOrder[i];\r\n                    if (speed === \"0\" || instant) {\r\n                        ctx.fillStyle = 'Aqua'\r\n                        this.drawCube(node.col, node.row)\r\n                    } else {\r\n                        let gradient = new Rainbow();\r\n                        gradient.setSpectrum('Yellow', 'Blue', 'Aqua')\r\n                        gradient.setNumberRange(0, 0.6)\r\n                        rects.push(new roundNode(node.col * resolution + 1, node.row * resolution + 1, resolution - 2, resolution - 2, resolution / 1.5, gradient))\r\n                    }\r\n                }\r\n            }, speed*i))\r\n        }\r\n    }\r\n\r\n    shortPath(nodesInShortestPathOrder, instant = false) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if(i===0 || i===nodesInShortestPathOrder.length-1) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                if (speed === \"0\" || instant) {\r\n                    ctx.fillStyle = 'Yellow'\r\n                    this.drawCube(node.col, node.row)\r\n                } else {\r\n                    let gradient = new Rainbow();\r\n                    gradient.setSpectrum('Red', 'Yellow')\r\n                    gradient.setNumberRange(0, 0.5)\r\n                    rects.push(new roundNode(node.col * resolution + 1, node.row * resolution + 1, resolution - 2, resolution - 2, resolution / 1.5, gradient))\r\n                }\r\n            }, speed!==\"0\" || instant ? 35 * i : 0));\r\n            timeouts.push(setTimeout(() => {\r\n                this.busy = false;\r\n            }, speed!==\"0\" || instant ? 35*nodesInShortestPathOrder.length : 0))\r\n        }\r\n    }\r\n\r\n    visualizeDijkstra(instant = false) {\r\n        if(this.busy) return;\r\n        this.busy = true;\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, instant);\r\n    }\r\n\r\n    visualizeGreedyBFS(instant = false) {\r\n        if(this.busy) return;\r\n        this.busy = true;\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(finishNode);\r\n        this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, instant);\r\n    }\r\n\r\n    visualize(instant = false) {\r\n        if(this.algorithm === 0) {\r\n            this.visualizeDijkstra(instant)\r\n        } else if(this.algorithm === 1) {\r\n            this.visualizeGreedyBFS(instant)\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region moving start & finish\r\n\r\n    moveStartOrFinish(x,y,start) {\r\n        let col\r\n        let row\r\n        if(start) {\r\n            col = START_NODE_COL;\r\n            row = START_NODE_ROW;\r\n        } else {\r\n            col = FINISH_NODE_COL;\r\n            row = FINISH_NODE_ROW\r\n        }\r\n        if(lastMousePos.x === x && lastMousePos.y === y) return;\r\n        lastMousePos = {x:x,y:y};\r\n        ctx.clearRect(col*resolution+1, row*resolution+1, resolution-2, resolution-2)\r\n        this.drawStartOrFinish(x,y, start)\r\n        if(this.state.grid[row][col].isWall) {\r\n            const newGrid = this.state.grid.slice()\r\n            newGrid[row][col].isWall = false;\r\n            this.setState({grid: newGrid})\r\n            this.drawWall(col,row)\r\n        }\r\n        if(start) {\r\n            START_NODE_COL = x;\r\n            START_NODE_ROW = y;\r\n        } else {\r\n            FINISH_NODE_COL = x;\r\n            FINISH_NODE_ROW = y;\r\n        }\r\n    }\r\n\r\n    drawStartOrFinish(x,y, start) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[y][x]\r\n\r\n        if(start) {\r\n            newGrid[START_NODE_ROW][START_NODE_COL] = {\r\n                ...newGrid[START_NODE_ROW][START_NODE_COL],\r\n                isStart: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isStart: true,\r\n            };\r\n            ctx.fillStyle = 'Green'\r\n        } else {\r\n            newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = {\r\n                ...newGrid[FINISH_NODE_ROW][FINISH_NODE_COL],\r\n                isFinish: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isFinish: true,\r\n            };\r\n            ctx.fillStyle = 'Red'\r\n        }\r\n        this.drawCube(x, y)\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    //#endregion\r\n\r\n    visualizeMaze() {\r\n        if(this.busy) return;\r\n        this.resetWalls()\r\n        this.clearVisualization()\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const maze = recursiveDivisionMaze(grid, startNode,finishNode)\r\n        if(speed === \"0\") {\r\n            for (const mazeElement of maze) {\r\n                this.drawWall(mazeElement[0], mazeElement[1])\r\n            }\r\n        } else {\r\n            for (let i = 0; i < maze.length; i++) {\r\n                const mazeElement = maze[i]\r\n                timeouts.push(setTimeout(() => this.drawWall(mazeElement[0], mazeElement[1]), speed*i))\r\n\r\n            }\r\n        }\r\n        this.redrawStartAndFinish()\r\n    }\r\n\r\n    drawLine(x,y, xd, yd) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x,y)\r\n        ctx.lineTo(xd, yd)\r\n        ctx.stroke();\r\n    }\r\n\r\n    drawCube(col,row) {\r\n        ctx.beginPath();\r\n        ctx.fillRect(col*resolution+1, row*resolution+1, resolution-2, resolution-2)\r\n        ctx.stroke();\r\n    }\r\n\r\n    calculateWall(e) {\r\n        const pos = this.getCursorPositionInGrid(e)\r\n        if(this.state.grid[pos.y][pos.x].isStart || this.state.grid[pos.y][pos.x].isFinish) {\r\n            return;\r\n        }\r\n\r\n        if(lastMousePos.x === pos.x && lastMousePos.y === pos.y) return;\r\n        lastMousePos = pos;\r\n        this.drawWall(pos.x,pos.y)\r\n    }\r\n\r\n    drawWall(x,y) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        let widthIn = Math.round(width/resolution)-1\r\n        let heightIn = Math.round(height/resolution)-1\r\n        if(x > widthIn || x < 0 || y > heightIn || y < 0) {\r\n            return;\r\n        }\r\n        const node = newGrid[y][x]\r\n        newGrid[y][x] = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        if(newGrid[y][x].isWall) {\r\n            // ctx.fillStyle = 'Black'\r\n            // this.drawCube(x, y)\r\n            if(speed !== \"0\") {\r\n                let gradient = new Rainbow();\r\n                gradient.setSpectrum('White', 'Black')\r\n                gradient.setNumberRange(0,0.5)\r\n                rects.push(new roundNode(node.col*resolution+1, node.row*resolution+1, resolution-2, resolution-2, resolution/1.5, gradient))\r\n            } else {\r\n                ctx.fillStyle = 'Black'\r\n                this.drawCube(x, y)\r\n            }\r\n        } else {\r\n            ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2,resolution-2)\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    //#region reset\r\n\r\n    clearVisualization(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice()\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(!grid[y][x].isWall && !grid[y][x].isStart && !grid[y][x].isFinish) {\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n                newGrid[y][x].isVisited = false;\r\n                newGrid[y][x].distance = Infinity;\r\n            }\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    redrawStartAndFinish() {\r\n        ctx.fillStyle = 'Green'\r\n        this.drawCube(START_NODE_COL,START_NODE_ROW)\r\n        ctx.fillStyle = 'Red'\r\n        this.drawCube(FINISH_NODE_COL,FINISH_NODE_ROW)\r\n        const newGrid = this.state.grid.slice()\r\n        newGrid[START_NODE_ROW][START_NODE_COL].isWall = false;\r\n        newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isWall = false;\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    resetWalls(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(grid[y][x].isWall) {\r\n                    newGrid[y][x].isWall = false;\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fullReset() {\r\n        START_NODE_COL = 5;\r\n        START_NODE_ROW = 5;\r\n\r\n        FINISH_NODE_COL = 20\r\n        FINISH_NODE_ROW = 5;\r\n\r\n        this.busy = false;\r\n\r\n        rects = []\r\n        this.setState({ grid: getInitialGrid() });\r\n        ctx.clearRect(0,0,canvas.width, canvas.height)\r\n        this.createGrid()\r\n        for (let i = 0; i < timeouts.length; i++) {\r\n            clearTimeout(timeouts[i]);\r\n        }\r\n        timeouts = []\r\n    }\r\n\r\n    //#endregion\r\n\r\n\r\n    // sliderChanged(id, val) {\r\n    //     if(id===0) {\r\n    //         this.setState({width: val})\r\n    //     } else if(id===1) {\r\n    //         this.setState({height: val})\r\n    //     }\r\n    //     this.reDrawGrid()\r\n    // }\r\n\r\n\r\n    render() {\r\n        // const {width,height} = this.state;\r\n\r\n        return (\r\n            <>\r\n                {/*<div style={{width: 100}}>*/}\r\n                {/*    <div>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={width} tipFormatter={value => `${value}%`} onChange={(val) => this.sliderChanged(0,val)}/>*/}\r\n                {/*        <label>{width}</label>*/}\r\n                {/*    </div>*/}\r\n                {/*    <div style={{height: 10}}/>*/}\r\n                {/*    <>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={height} onChange={(val) => this.sliderChanged(1,val)}/>*/}\r\n                {/*        <label>{height}</label>*/}\r\n                {/*    </>*/}\r\n                {/*</div>*/}\r\n                <div>\r\n                    <FormControl variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                        <InputLabel id=\"demo-simple-select-label\">Speeds</InputLabel>\r\n                        <Select id={\"speed\"} defaultValue={\"5\"} style={{textAlign: 'center'}} onChange={(event) => {\r\n                            speed = event.target.value;\r\n                        }}>\r\n                            <MenuItem value=\"80\">Slow</MenuItem>\r\n                            <MenuItem value=\"30\">Fast</MenuItem>\r\n                            <MenuItem value=\"15\">Faster</MenuItem>\r\n                            <MenuItem value=\"5\">Extra Fast</MenuItem>\r\n                            <MenuItem value=\"0\">Instant</MenuItem>\r\n                        </Select>\r\n                    </FormControl>\r\n                </div>\r\n                <div>\r\n                    <FormControl className={\"customSelect\"} variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                        <InputLabel id=\"demo-simple-select-label\">Algorithms</InputLabel>\r\n                        <Select\r\n                            labelId=\"demo-simple-select-label\"\r\n                            id=\"demo-simple-select\"\r\n                            label=\"Algorithms\"\r\n                            defaultValue={0}\r\n                            onChange={(event) => {\r\n                                this.algorithm = event.target.value;\r\n                            }}\r\n                        >\r\n                                <MenuItem value={0}>Dijkstra algorithm</MenuItem>\r\n                                <MenuItem value={1}>Greedy best first search</MenuItem>\r\n                        </Select>\r\n                    </FormControl>\r\n                    <ButtonGroup variant=\"contained\">\r\n                        <Button onClick={() => this.visualize()}>Visualize</Button>\r\n                        <Button onClick={() => this.fullReset()}>Reset</Button>\r\n                        <Button onClick={() => this.resetWalls()}>Clear walls</Button>\r\n                        <Button onClick={() => this.clearVisualization()}>Clear path</Button>\r\n                    </ButtonGroup>\r\n                </div>\r\n                <ButtonGroup variant=\"contained\" style={{transform: \"translateY(-25%)\"}}>\r\n                    <Button onClick={() => this.visualizeMaze()}>Generate maze</Button>\r\n                </ButtonGroup>\r\n                <canvas\r\n                    id={\"canvas\"}\r\n                    // onClick={(e) =>  this.calculateWall(e)}\r\n                    onMouseDown={(e) => this.handleMouseDown(e)}\r\n                    onMouseMove={(e) =>\r\n                        this.handleMouseMove(e)\r\n                    }\r\n                    onMouseUp={(e) => this.handleMouseUp(e)}\r\n                />\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        prevNode: null,\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nfunction randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = []\r\n    for (let row = 0; row < height/resolution; row++) {\r\n        const currentRow = []\r\n        for (let col = 0; col < width/resolution; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};","import React from 'react';\nimport './App.css';\nimport Visualizer from \"./Visualizer/visualizer\";\nimport gitLogo from \"./GitHub-Mark-64px.png\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n          <a href=\"https://github.com/tddebart/better-pathfinding-visualizer\" target=\"_blank\">\n            <img className={\"github\"} src={gitLogo} alt={\"github\"} />\n          </a>\n          <Visualizer/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyRTk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNTE3OEEyRjk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJDOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJEOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FYrpWAAABrNJREFUeNrkW2ls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\"","\n\nconst reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}