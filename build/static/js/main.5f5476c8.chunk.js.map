{"version":3,"sources":["mazeAlgorithms/recursive.js","algorithms/dijkstra.js","Visualizer/visualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["walls","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","col","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","prevNode","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","canvas","ctx","resolution","width","getWidth","height","getHeight","START_NODE_COL","START_NODE_ROW","FINISH_NODE_COL","FINISH_NODE_ROW","timeouts","speed","lastFrameTime","lastMousePos","x","y","mouseStillPressed","rects","howManyCells","less","window","innerWidth","innerHeight","roundNode","radius","gradient","this","color","time","frame","clearRect","fillStyle","colourAt","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","Visualizer","props","resize","forceUpdate","fullReset","state","mouseIsPressed","isDraggingStart","isDraggingFinish","removeEventListener","setState","getInitialGrid","createGrid","addEventListener","document","getElementById","getContext","createPartGrid","drawCube","drawLine","requestAnimationFrame","draw","bind","deltaTime","strokeStyle","event","rect","getBoundingClientRect","clientX","left","clientY","top","pos","getCursorPositionInPixels","e","busy","cursPos","getCursorPositionInGrid","isStart","isFinish","moveStart","moveFinish","calculateWall","nodesInShortestPathOrder","clearVisualization","setTimeout","shortPath","Rainbow","setSpectrum","setNumberRange","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","drawStartOrFinish","start","newGrid","resetWalls","maze","mazeElement","drawWall","xd","yd","stroke","fillRect","widthIn","round","heightIn","j","console","log","skipBusyCheck","clearTimeout","FormControl","variant","sx","m","minWidth","InputLabel","id","Select","defaultValue","style","textAlign","onChange","target","value","MenuItem","className","labelId","label","ButtonGroup","Button","onClick","visualizeDijkstra","showStart","transform","visualizeMaze","onMouseDown","handleMouseDown","onMouseMove","handleMouseMove","onMouseUp","handleMouseUp","Component","createNode","currentRow","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5f5476c8.chunk.js","sourcesContent":["let walls;\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let vertical = range(grid.length);\r\n    let horizontal = range(grid[0].length);\r\n    walls = [];\r\n    getRecursiveWalls(vertical, horizontal, startNode, finishNode);\r\n    return walls;\r\n}\r\n\r\nfunction range(len) {\r\n    let result = [];\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, startNode, finishNode) {\r\n    if (vertical.length < 2 || horizontal.length < 2) {\r\n        return;\r\n    }\r\n    let dir;\r\n    let num;\r\n    if (vertical.length > horizontal.length) {\r\n        dir = 0;\r\n        num = generateOddRandomNumber(vertical);\r\n    }\r\n    if (vertical.length <= horizontal.length) {\r\n        dir = 1;\r\n        num = generateOddRandomNumber(horizontal);\r\n    }\r\n\r\n    if (dir === 0) {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical.slice(0, vertical.indexOf(num)),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical.slice(vertical.indexOf(num) + 1),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n    } else {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(0, horizontal.indexOf(num)),\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(horizontal.indexOf(num) + 1),\r\n            startNode,\r\n            finishNode\r\n        );\r\n    }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n    let max = array.length - 1;\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 === 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n    if (dir === 0) {\r\n        if (horizontal.length === 2) return;\r\n        for (let temp of horizontal) {\r\n            if (\r\n                (temp === startNode.row && num === startNode.col) ||\r\n                (num === finishNode.row && temp === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([temp, num]);\r\n        }\r\n    } else {\r\n        if (vertical.length === 2) return;\r\n        for (let temp of vertical) {\r\n            if (\r\n                (num === startNode.row && temp === startNode.col) ||\r\n                (temp === finishNode.row && num === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([num, temp]);\r\n        }\r\n    }\r\n    if (!isStartFinish) {\r\n        tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n    }\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall);\r\n    }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 !== 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return randomNum;\r\n}","\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode.row === finishNode.row && closestNode.col === finishNode.col) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.prevNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);// 0 -1\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // 0 1\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);// -1 0\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // 1 0\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","import React, {Component} from 'react';\r\nimport \"./visualizer.css\"\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra'\r\nimport {recursiveDivisionMaze} from '../mazeAlgorithms/recursive'\r\nimport 'rc-slider/assets/index.css';\r\nimport Rainbow from 'rainbowvis.js'\r\nimport {ButtonGroup, Button, Select, MenuItem, InputLabel, FormControl} from \"@mui/material\";\r\n\r\nconst resolution = 29\r\nlet width = getWidth()\r\nlet height =  getHeight()\r\n\r\nlet START_NODE_COL = 5;\r\nlet START_NODE_ROW = 5;\r\n\r\nlet FINISH_NODE_COL = 20\r\nlet FINISH_NODE_ROW = 5;\r\n\r\nlet timeouts = [];\r\n\r\nlet canvas;\r\nlet ctx;\r\n\r\nlet speed = 0;\r\n\r\nconst FRAMES_PER_SECOND = 60;  // Valid values are 60,30,20,15,10...\r\n// set the mim time to render the next frame\r\nconst FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;\r\nlet lastFrameTime = 0;  // the last frame time\r\n\r\nlet lastMousePos = {x:0,y:0}\r\n\r\nlet mouseStillPressed = false;\r\n\r\nlet rects = [];\r\n\r\nfunction getWidth() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerWidth/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nfunction getHeight() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerHeight*0.85/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nclass roundNode {\r\n    constructor(x, y, width, height, radius, gradient) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.radius = radius;\r\n        this.color = \"Black\";\r\n        this.time = 0;\r\n        this.gradient = gradient;\r\n    }\r\n\r\n    draw(time) {\r\n        this.time += time;\r\n\r\n        this.frame = Math.floor(this.time)/847\r\n\r\n        // if(this.gradient === undefined) {\r\n        //     this.color = \"Yellow\";\r\n        // } else {\r\n        //     this.color = \"Blue\"\r\n        // }\r\n\r\n        ctx.clearRect(this.x, this.y, this.width, this.height);\r\n\r\n        ctx.fillStyle = \"#\"+this.gradient.colourAt(this.frame)\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.x + this.radius, this.y);\r\n        ctx.lineTo(this.x + this.width - this.radius, this.y);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + this.radius);\r\n        ctx.lineTo(this.x + this.width, this.y + this.height - this.radius);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - this.radius, this.y + this.height);\r\n        ctx.lineTo(this.x + this.radius, this.y + this.height);\r\n        ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - this.radius);\r\n        ctx.lineTo(this.x, this.y + this.radius);\r\n        ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);\r\n        ctx.closePath();\r\n        ctx.fill()\r\n\r\n\r\n        if(this.radius > 0) {\r\n            this.radius -= 0.56\r\n        } else {\r\n            rects.splice(rects.indexOf(this), 1);\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Visualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            isDraggingStart: false,\r\n            isDraggingFinish: false,\r\n        };\r\n    }\r\n\r\n    resize = () =>  {\r\n        width = getWidth();\r\n        height = getHeight();\r\n        this.forceUpdate()\r\n        this.fullReset()\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.resize)\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.setState({ grid: getInitialGrid() });\r\n        this.createGrid();\r\n        window.addEventListener('resize', this.resize)\r\n    }\r\n\r\n    //#region grid\r\n\r\n    createGrid() {\r\n        canvas = document.getElementById('canvas');\r\n        ctx = canvas.getContext('2d')\r\n\r\n        canvas.width = width\r\n        canvas.height = height\r\n\r\n        for (let y = 0; y < canvas.height; y+= resolution) {\r\n            for (let x = 0; x < canvas.width; x+= resolution) {\r\n                this.createPartGrid(x,y)\r\n                if(x/resolution === START_NODE_COL && y/resolution === START_NODE_ROW) {\r\n                    ctx.fillStyle = 'Green'\r\n                    this.drawCube(x/resolution,y/resolution)\r\n                }\r\n                if(x/resolution === FINISH_NODE_COL && y/resolution === FINISH_NODE_ROW) {\r\n                    ctx.fillStyle = 'Red'\r\n                    this.drawCube(x/resolution,y/resolution)\r\n                }\r\n            }\r\n        }\r\n        this.drawLine(0,canvas.height,canvas.width,canvas.height)\r\n        this.drawLine(canvas.width,0,canvas.width,canvas.height)\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    draw(time) {\r\n        const deltaTime = time - lastFrameTime\r\n        if(deltaTime < FRAME_MIN_TIME) {\r\n            window.requestAnimationFrame(this.draw.bind(this));\r\n            return;\r\n        }\r\n        lastFrameTime = time;\r\n        for (const rect of rects) {\r\n            rect.draw(deltaTime)\r\n        }\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    createPartGrid(x,y) {\r\n        ctx.strokeStyle = 'Black'\r\n        this.drawLine(x,y, x, y+resolution)\r\n        this.drawLine(x,y, x+resolution, y)\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region mouse\r\n    getCursorPositionInPixels(event) {\r\n        const rect = canvas.getBoundingClientRect()\r\n        const x = event.clientX - rect.left\r\n        const y = event.clientY - rect.top\r\n        return {x: x, y: y}\r\n    }\r\n\r\n    getCursorPositionInGrid(event) {\r\n        const pos = this.getCursorPositionInPixels(event)\r\n        return {x: Math.floor(pos.x/resolution), y: Math.floor(pos.y/resolution)}\r\n    }\r\n\r\n    handleMouseDown(e) {\r\n        if(this.busy) return;\r\n\r\n        const cursPos = this.getCursorPositionInGrid(e)\r\n        const {grid} = this.state;\r\n        if(grid[cursPos.y][cursPos.x].isStart) {\r\n            this.setState({isDraggingStart: true})\r\n        } else if(grid[cursPos.y][cursPos.x].isFinish) {\r\n            this.setState({isDraggingFinish: true})\r\n        }\r\n\r\n        this.setState({mouseIsPressed: true});\r\n        mouseStillPressed = true;\r\n    }\r\n\r\n    handleMouseMove(e) {\r\n        if(this.busy) return;\r\n\r\n        // console.log(this.getCursorPosition(e).x + \" | \" + this.getCursorPosition(e).y)\r\n        if (!this.state.mouseIsPressed) return;\r\n        if(this.state.isDraggingStart) {\r\n            const pos = this.getCursorPositionInGrid(e)\r\n            this.moveStart(pos.x,pos.y)\r\n        } else if(this.state.isDraggingFinish) {\r\n            const pos = this.getCursorPositionInGrid(e)\r\n            this.moveFinish(pos.x,pos.y)\r\n        } else {\r\n            this.calculateWall(e);\r\n        }\r\n        mouseStillPressed = false;\r\n    }\r\n\r\n    handleMouseUp(e) {\r\n        if(this.busy) return;\r\n\r\n        this.setState({mouseIsPressed: false, isDraggingStart: false, isDraggingFinish: false});\r\n        if(mouseStillPressed && !this.state.isDraggingStart && !this.state.isDraggingFinish) {\r\n            lastMousePos.x++;\r\n            this.calculateWall(e);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region dijkstra visual\r\n\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        this.clearVisualization(true);\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if(i===0) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                if(i === visitedNodesInOrder.length-1) {\r\n                    this.shortPath(nodesInShortestPathOrder);\r\n                } else {\r\n                    const node = visitedNodesInOrder[i];\r\n                    if(speed !== \"0\") {\r\n                        let gradient = new Rainbow();\r\n                        gradient.setSpectrum('Yellow', 'Blue', 'Aqua')\r\n                        gradient.setNumberRange(0,0.6)\r\n                        rects.push(new roundNode(node.col*resolution+1, node.row*resolution+1, resolution-2, resolution-2, resolution/1.5, gradient))\r\n                    } else {\r\n                        ctx.fillStyle = 'Aqua'\r\n                        this.drawCube(node.col,node.row)\r\n                    }\r\n                }\r\n            }, speed*i))\r\n        }\r\n    }\r\n\r\n    shortPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if(i===0 || i===nodesInShortestPathOrder.length-1) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                if(speed !== \"0\") {\r\n                    let gradient = new Rainbow();\r\n                    gradient.setSpectrum('Red', 'Yellow')\r\n                    gradient.setNumberRange(0,0.5)\r\n                    rects.push(new roundNode(node.col*resolution+1, node.row*resolution+1, resolution-2, resolution-2, resolution/1.5, gradient))\r\n                } else {\r\n                    ctx.fillStyle = 'Yellow'\r\n                    this.drawCube(node.col,node.row)\r\n                }\r\n            }, speed!==\"0\" ? 35 * i : 0));\r\n            timeouts.push(setTimeout(() => {\r\n                this.busy = false;\r\n            }, speed!==\"0\" ? 35*nodesInShortestPathOrder.length : 0))\r\n        }\r\n    }\r\n\r\n    visualizeDijkstra() {\r\n        if(this.busy) return;\r\n        this.busy = true;\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region moving start & finish\r\n\r\n    moveStart(x,y) {\r\n        ctx.clearRect(START_NODE_COL*resolution+1, START_NODE_ROW*resolution+1, resolution-2, resolution-2)\r\n        this.drawStartOrFinish(x,y, true)\r\n        START_NODE_COL = x;\r\n        START_NODE_ROW = y;\r\n    }\r\n\r\n    moveFinish(x,y) {\r\n        // const pos = this.getCursorPositionInGrid(e)\r\n        ctx.clearRect(FINISH_NODE_COL*resolution+1, FINISH_NODE_ROW*resolution+1, resolution-2, resolution-2)\r\n        this.drawStartOrFinish(x,y, false)\r\n        FINISH_NODE_COL = x;\r\n        FINISH_NODE_ROW = y;\r\n\r\n        // const prevSpeed = speed;\r\n        // speed = 0;\r\n        // this.visualizeDijkstra();\r\n        // speed = prevSpeed;\r\n    }\r\n\r\n    drawStartOrFinish(x,y, start) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[y][x]\r\n        if(start) {\r\n            newGrid[START_NODE_ROW][START_NODE_COL] = {\r\n                ...newGrid[START_NODE_ROW][START_NODE_COL],\r\n                isStart: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isStart: true,\r\n            };\r\n            ctx.fillStyle = 'Green'\r\n        } else {\r\n            newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = {\r\n                ...newGrid[FINISH_NODE_ROW][FINISH_NODE_COL],\r\n                isFinish: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isFinish: true,\r\n            };\r\n            ctx.fillStyle = 'Red'\r\n        }\r\n        this.drawCube(x, y)\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    //#endregion\r\n\r\n    visualizeMaze() {\r\n        if(this.busy) return;\r\n        this.resetWalls()\r\n        this.clearVisualization()\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const maze = recursiveDivisionMaze(grid, startNode,finishNode)\r\n        if(speed === \"0\") {\r\n            for (const mazeElement of maze) {\r\n                this.drawWall(mazeElement[0], mazeElement[1])\r\n            }\r\n        } else {\r\n            for (let i = 0; i < maze.length; i++) {\r\n                const mazeElement = maze[i]\r\n                timeouts.push(setTimeout(() => this.drawWall(mazeElement[0], mazeElement[1]), speed*i))\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawLine(x,y, xd, yd) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x,y)\r\n        ctx.lineTo(xd, yd)\r\n        ctx.stroke();\r\n    }\r\n\r\n    drawCube(col,row) {\r\n        ctx.beginPath();\r\n        ctx.fillRect(col*resolution+1, row*resolution+1, resolution-2, resolution-2)\r\n        ctx.stroke();\r\n    }\r\n\r\n    calculateWall(e) {\r\n        const pos = this.getCursorPositionInGrid(e)\r\n        if(this.state.grid[pos.y][pos.x].isStart || this.state.grid[pos.y][pos.x].isFinish) {\r\n            return;\r\n        }\r\n\r\n        if(lastMousePos.x === pos.x && lastMousePos.y === pos.y) return;\r\n        lastMousePos = pos;\r\n        this.drawWall(pos.x,pos.y)\r\n    }\r\n\r\n    drawWall(x,y) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        let widthIn = Math.round(width/resolution)-1\r\n        let heightIn = Math.round(height/resolution)-1\r\n        if(x > widthIn || x < 0 || y > heightIn || y < 0) {\r\n            return;\r\n        }\r\n        const node = newGrid[y][x]\r\n        newGrid[y][x] = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        if(newGrid[y][x].isWall) {\r\n            // ctx.fillStyle = 'Black'\r\n            // this.drawCube(x, y)\r\n            if(speed !== \"0\") {\r\n                let gradient = new Rainbow();\r\n                gradient.setSpectrum('White', 'Black')\r\n                gradient.setNumberRange(0,0.5)\r\n                rects.push(new roundNode(node.col*resolution+1, node.row*resolution+1, resolution-2, resolution-2, resolution/1.5, gradient))\r\n            } else {\r\n                ctx.fillStyle = 'Black'\r\n                this.drawCube(x, y)\r\n            }\r\n        } else {\r\n            ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2,resolution-2)\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    showStart() {\r\n        const {grid} = this.state;\r\n        for (let i = 0; i < grid.length; i++) {\r\n            for (let j = 0; j < grid[i].length; j++) {\r\n                if(grid[i][j].isStart) {\r\n                    console.log(\"Start is at x:\" + j + \" y:\" + i)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //#region reset\r\n\r\n    clearVisualization(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice()\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(!grid[y][x].isWall && !grid[y][x].isStart && !grid[y][x].isFinish) {\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n                newGrid[y][x].isVisited = false;\r\n                newGrid[y][x].distance = Infinity;\r\n            }\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    resetWalls(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(grid[y][x].isWall) {\r\n                    newGrid[y][x].isWall = false;\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fullReset() {\r\n        START_NODE_COL = 5;\r\n        START_NODE_ROW = 5;\r\n\r\n        FINISH_NODE_COL = 20\r\n        FINISH_NODE_ROW = 5;\r\n\r\n        this.busy = false;\r\n\r\n        rects = []\r\n        this.setState({ grid: getInitialGrid() });\r\n        ctx.clearRect(0,0,canvas.width, canvas.height)\r\n        this.createGrid()\r\n        for (let i = 0; i < timeouts.length; i++) {\r\n            clearTimeout(timeouts[i]);\r\n        }\r\n        timeouts = []\r\n    }\r\n\r\n    //#endregion\r\n\r\n\r\n    // sliderChanged(id, val) {\r\n    //     if(id===0) {\r\n    //         this.setState({width: val})\r\n    //     } else if(id===1) {\r\n    //         this.setState({height: val})\r\n    //     }\r\n    //     this.reDrawGrid()\r\n    // }\r\n\r\n\r\n    render() {\r\n        // const {width,height} = this.state;\r\n\r\n        return (\r\n            <>\r\n                {/*<div style={{width: 100}}>*/}\r\n                {/*    <div>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={width} tipFormatter={value => `${value}%`} onChange={(val) => this.sliderChanged(0,val)}/>*/}\r\n                {/*        <label>{width}</label>*/}\r\n                {/*    </div>*/}\r\n                {/*    <div style={{height: 10}}/>*/}\r\n                {/*    <>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={height} onChange={(val) => this.sliderChanged(1,val)}/>*/}\r\n                {/*        <label>{height}</label>*/}\r\n                {/*    </>*/}\r\n                {/*</div>*/}\r\n                <div>\r\n                    <FormControl variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                        <InputLabel id=\"demo-simple-select-label\">Speeds</InputLabel>\r\n                        <Select id={\"speed\"} defaultValue={\"0\"} style={{textAlign: 'center'}} onChange={(event) => {\r\n                            speed = event.target.value;\r\n                            console.log( event.target.value)\r\n                        }}>\r\n                            <MenuItem value=\"80\">Slow</MenuItem>\r\n                            <MenuItem value=\"30\">Fast</MenuItem>\r\n                            <MenuItem value=\"15\">Faster</MenuItem>\r\n                            <MenuItem value=\"5\">Extra Fast</MenuItem>\r\n                            <MenuItem value=\"0\">Instant</MenuItem>\r\n                        </Select>\r\n                    </FormControl>\r\n                </div>\r\n                <div>\r\n                    <FormControl className={\"customSelect\"} variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                        <InputLabel id=\"demo-simple-select-label\">Algorithms</InputLabel>\r\n                        <Select\r\n                            labelId=\"demo-simple-select-label\"\r\n                            id=\"demo-simple-select\"\r\n                            label=\"Algorithms\"\r\n                            defaultValue={0}\r\n                        >\r\n                                <MenuItem value={0}>Dijkstra algorithm</MenuItem>\r\n                                <MenuItem value={1}>C* algorithm</MenuItem>\r\n                        </Select>\r\n                    </FormControl>\r\n                    <ButtonGroup variant=\"contained\">\r\n                        <Button onClick={() => this.visualizeDijkstra()}>Visualize</Button>\r\n                        <Button onClick={() => this.fullReset()}>Reset</Button>\r\n                        <Button onClick={() => this.resetWalls()}>Clear walls</Button>\r\n                        <Button onClick={() => this.showStart()}>Start</Button>\r\n                        <Button onClick={() => this.clearVisualization()}>Clear path</Button>\r\n                    </ButtonGroup>\r\n                </div>\r\n                <ButtonGroup variant=\"contained\" style={{transform: \"translateY(-25%)\"}}>\r\n                    <Button onClick={() => this.visualizeMaze()}>Generate maze</Button>\r\n                </ButtonGroup>\r\n                <canvas\r\n                    id={\"canvas\"}\r\n                    // onClick={(e) =>  this.calculateWall(e)}\r\n                    onMouseDown={(e) => this.handleMouseDown(e)}\r\n                    onMouseMove={(e) =>\r\n                        this.handleMouseMove(e)\r\n                    }\r\n                    onMouseUp={(e) => this.handleMouseUp(e)}\r\n                />\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        prevNode: null,\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nfunction randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = []\r\n    for (let row = 0; row < height/resolution; row++) {\r\n        const currentRow = []\r\n        for (let col = 0; col < width/resolution; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};","import React from 'react';\nimport './App.css';\nimport Visualizer from \"./Visualizer/visualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n          <Visualizer/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","\n\nconst reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}