{"version":3,"sources":["mazeAlgorithms/recursive.js","algorithms/dijkstra.js","algorithms/greedyBestFirstSearch.js","algorithms/aStar.js","Visualizer/visualizer.jsx","mazeAlgorithms/randomMaze.js","GitHub-Mark-64px.png","App.js","reportWebVitals.js","index.js"],"names":["walls","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","col","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","prevNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","greedyBFS","a","b","totalDistance","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","manhattenDistance","Math","abs","getNodesInShortestPathOrderGreedyBFS","astar","getNodesInShortestPathOrderAstar","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","floor","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","canvas","ctx","resolution","width","getWidth","height","getHeight","START_NODE_COL","START_NODE_ROW","FINISH_NODE_COL","FINISH_NODE_ROW","timeouts","speed","lastFrameTime","lastMousePos","x","y","mouseStillPressed","rects","howManyCells","less","window","innerWidth","innerHeight","roundNode","radius","gradient","this","color","time","frame","clearRect","fillStyle","colourAt","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","fill","Visualizer","props","resize","forceUpdate","fullReset","state","mouseIsPressed","isDraggingStart","isDraggingFinish","removeEventListener","setState","getInitialGrid","createGrid","addEventListener","algorithm","maze","document","getElementById","getContext","createPartGrid","drawCube","drawLine","requestAnimationFrame","draw","bind","deltaTime","strokeStyle","event","rect","getBoundingClientRect","clientX","left","clientY","top","pos","getCursorPositionInPixels","e","busy","cursPos","getCursorPositionInGrid","isStart","isFinish","moveStartOrFinish","calculateWall","instant","clearVisualization","setTimeout","shortPath","Rainbow","setSpectrum","setNumberRange","animateAlgorithm","start","drawStartOrFinish","newGrid","drawWall","resetWalls","randomMaze","mazeElement","redrawStartAndFinish","xd","yd","stroke","fillRect","widthIn","round","heightIn","skipBusyCheck","clearTimeout","AppBar","Toolbar","href","target","rel","className","src","alt","Typography","variant","component","style","marginLeft","FormControl","sx","m","minWidth","InputLabel","id","Select","defaultValue","textAlign","onChange","value","MenuItem","labelId","label","ButtonGroup","Button","onClick","visualize","visualizeMaze","onMouseDown","handleMouseDown","onMouseMove","handleMouseMove","onMouseUp","handleMouseUp","Component","createNode","currentRow","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0e86ed27.chunk.js","sourcesContent":["let walls;\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let vertical = range(grid.length);\r\n    let horizontal = range(grid[0].length);\r\n    walls = [];\r\n    getRecursiveWalls(vertical, horizontal, startNode, finishNode);\r\n    return walls;\r\n}\r\n\r\nfunction range(len) {\r\n    let result = [];\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, startNode, finishNode) {\r\n    if (vertical.length < 2 || horizontal.length < 2) {\r\n        return;\r\n    }\r\n    let dir;\r\n    let num;\r\n    if (vertical.length > horizontal.length) {\r\n        dir = 0;\r\n        num = generateOddRandomNumber(vertical);\r\n    }\r\n    if (vertical.length <= horizontal.length) {\r\n        dir = 1;\r\n        num = generateOddRandomNumber(horizontal);\r\n    }\r\n\r\n    if (dir === 0) {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical.slice(0, vertical.indexOf(num)),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical.slice(vertical.indexOf(num) + 1),\r\n            horizontal,\r\n            startNode,\r\n            finishNode\r\n        );\r\n    } else {\r\n        addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(0, horizontal.indexOf(num)),\r\n            startNode,\r\n            finishNode\r\n        );\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(horizontal.indexOf(num) + 1),\r\n            startNode,\r\n            finishNode\r\n        );\r\n    }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n    let max = array.length - 1;\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 === 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n    if (dir === 0) {\r\n        if (horizontal.length === 2) return;\r\n        for (let temp of horizontal) {\r\n            if (\r\n                (temp === startNode.row && num === startNode.col) ||\r\n                (num === finishNode.row && temp === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([temp, num]);\r\n        }\r\n    } else {\r\n        if (vertical.length === 2) return;\r\n        for (let temp of vertical) {\r\n            if (\r\n                (num === startNode.row && temp === startNode.col) ||\r\n                (temp === finishNode.row && num === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([num, temp]);\r\n        }\r\n    }\r\n    if (!isStartFinish) {\r\n        tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n    }\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall);\r\n    }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 !== 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return randomNum;\r\n}","\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if (closestNode.row === finishNode.row && closestNode.col === finishNode.col) return visitedNodesInOrder;\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.prevNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);// 0 -1\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // 0 1\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);// -1 0\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // 1 0\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","export function greedyBFS(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let unvisitedNodes = []; //open list\r\n    let visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    unvisitedNodes.push(startNode);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        let neighbours = getNeighbours(closestNode, grid);\r\n        for (let neighbour of neighbours) {\r\n            let distance = closestNode.distance + 1;\r\n            //f(n) = h(n)\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n                unvisitedNodes.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            } else if (distance < neighbour.distance) {\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            }\r\n        }\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    let neighbours = [];\r\n    let { col, row } = node;\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n    return neighbours.filter((neighbour) => !neighbour.isWall && !neighbour.isVisited);\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n    let x = Math.abs(node.row - finishNode.row);\r\n    let y = Math.abs(node.col - finishNode.col);\r\n    return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n    for (let node of unvisitedNodes) {\r\n        if (node.row === neighbour.row && node.col === neighbour.col) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderGreedyBFS(finishNode) {\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","export function astar(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let unvisitedNodes = []; //open list\r\n    let visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    unvisitedNodes.push(startNode);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n        let closestNode = unvisitedNodes.shift();\r\n\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n\r\n        let neighbours = getNeighbours(closestNode, grid);\r\n        for (let neighbour of neighbours) {\r\n            let distance = closestNode.distance + 1;\r\n            //f(n) = g(n) + h(n)\r\n            if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n                unvisitedNodes.unshift(neighbour);\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance =\r\n                    distance + manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            } else if (distance < neighbour.distance) {\r\n                neighbour.distance = distance;\r\n                neighbour.totalDistance =\r\n                    distance + manhattenDistance(neighbour, finishNode);\r\n                neighbour.prevNode = closestNode;\r\n            }\r\n        }\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    let neighbours = [];\r\n    let { row, col } = node;\r\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n    return neighbours.filter(\r\n        (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n    );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n    for (let node of unvisitedNodes) {\r\n        if (node.row === neighbour.row && node.col === neighbour.col) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction manhattenDistance(node, finishNode) {\r\n    let x = Math.abs(node.row - finishNode.row);\r\n    let y = Math.abs(node.col - finishNode.col);\r\n    return x + y;\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAstar(finishNode) {\r\n    let nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.prevNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}","import React, {Component} from 'react';\r\nimport \"./visualizer.css\"\r\n\r\n// Pathfinding\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra'\r\nimport {greedyBFS, getNodesInShortestPathOrderGreedyBFS} from '../algorithms/greedyBestFirstSearch'\r\nimport {astar, getNodesInShortestPathOrderAstar} from '../algorithms/aStar'\r\n\r\n// Maze\r\nimport {recursiveDivisionMaze} from '../mazeAlgorithms/recursive'\r\nimport {randomMaze} from '../mazeAlgorithms/randomMaze'\r\n\r\n// Visual and useful\r\nimport 'rc-slider/assets/index.css';\r\nimport Rainbow from 'rainbowvis.js'\r\nimport {\r\n    ButtonGroup,\r\n    Button,\r\n    Select,\r\n    MenuItem,\r\n    InputLabel,\r\n    FormControl,\r\n    AppBar,\r\n    Toolbar,\r\n    Typography, Container\r\n} from \"@mui/material\";\r\nimport gitLogo from \"../GitHub-Mark-64px.png\";\r\n\r\nconst resolution = 29\r\nlet width = getWidth()\r\nlet height =  getHeight()\r\n\r\nlet START_NODE_COL = 5;\r\nlet START_NODE_ROW = 5;\r\n\r\nlet FINISH_NODE_COL = 20\r\nlet FINISH_NODE_ROW = 5;\r\n\r\n// the setTimeouts that are currently waiting\r\nlet timeouts = [];\r\n\r\nlet canvas;\r\nlet ctx;\r\n\r\nlet speed = 5;\r\n\r\nconst FRAMES_PER_SECOND = 60;  // Valid values are 60,30,20,15,10...\r\n// set the mim time to render the next frame\r\nconst FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;\r\nlet lastFrameTime = 0;  // the last frame time\r\n\r\nlet lastMousePos = {x:0,y:0}\r\n\r\nlet mouseStillPressed = false;\r\n\r\nlet rects = [];\r\n\r\nfunction getWidth() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerWidth/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nfunction getHeight() {\r\n    let howManyCells = 0\r\n    let less = 0\r\n    while(howManyCells % 2 === 0) {\r\n        howManyCells = Math.floor(window.innerHeight*0.95/resolution)-less;\r\n        less++\r\n    }\r\n    return howManyCells*resolution;\r\n}\r\n\r\nclass roundNode {\r\n    constructor(x, y, width, height, radius, gradient) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.radius = radius;\r\n        this.color = \"Black\";\r\n        this.time = 0;\r\n        this.gradient = gradient;\r\n    }\r\n\r\n    draw(time) {\r\n        this.time += time;\r\n\r\n        this.frame = Math.floor(this.time)/847\r\n\r\n        // if(this.gradient === undefined) {\r\n        //     this.color = \"Yellow\";\r\n        // } else {\r\n        //     this.color = \"Blue\"\r\n        // }\r\n\r\n        ctx.clearRect(this.x, this.y, this.width, this.height);\r\n\r\n        ctx.fillStyle = \"#\"+this.gradient.colourAt(this.frame)\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.x + this.radius, this.y);\r\n        ctx.lineTo(this.x + this.width - this.radius, this.y);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + this.radius);\r\n        ctx.lineTo(this.x + this.width, this.y + this.height - this.radius);\r\n        ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - this.radius, this.y + this.height);\r\n        ctx.lineTo(this.x + this.radius, this.y + this.height);\r\n        ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - this.radius);\r\n        ctx.lineTo(this.x, this.y + this.radius);\r\n        ctx.quadraticCurveTo(this.x, this.y, this.x + this.radius, this.y);\r\n        ctx.closePath();\r\n        ctx.fill()\r\n\r\n\r\n        if(this.radius > 0) {\r\n            this.radius -= 0.56\r\n        } else {\r\n            rects.splice(rects.indexOf(this), 1);\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Visualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            isDraggingStart: false,\r\n            isDraggingFinish: false,\r\n        };\r\n    }\r\n\r\n    resize = () => {\r\n        width = getWidth();\r\n        height = getHeight();\r\n        this.forceUpdate()\r\n        this.fullReset()\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.resize)\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.setState({grid: getInitialGrid()});\r\n        this.createGrid();\r\n        window.addEventListener('resize', this.resize)\r\n        this.algorithm = 0;\r\n        this.maze = 0;\r\n    }\r\n\r\n    //#region grid\r\n\r\n    createGrid() {\r\n        canvas = document.getElementById('canvas');\r\n        ctx = canvas.getContext('2d')\r\n\r\n        canvas.width = width\r\n        canvas.height = height\r\n\r\n        for (let y = 0; y < canvas.height; y += resolution) {\r\n            for (let x = 0; x < canvas.width; x += resolution) {\r\n                this.createPartGrid(x, y)\r\n                if (x / resolution === START_NODE_COL && y / resolution === START_NODE_ROW) {\r\n                    ctx.fillStyle = 'Green'\r\n                    this.drawCube(x / resolution, y / resolution)\r\n                }\r\n                if (x / resolution === FINISH_NODE_COL && y / resolution === FINISH_NODE_ROW) {\r\n                    ctx.fillStyle = 'Red'\r\n                    this.drawCube(x / resolution, y / resolution)\r\n                }\r\n            }\r\n        }\r\n        this.drawLine(0, canvas.height, canvas.width, canvas.height)\r\n        this.drawLine(canvas.width, 0, canvas.width, canvas.height)\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    draw(time) {\r\n        const deltaTime = time - lastFrameTime\r\n        if (deltaTime < FRAME_MIN_TIME) {\r\n            window.requestAnimationFrame(this.draw.bind(this));\r\n            return;\r\n        }\r\n        lastFrameTime = time;\r\n        for (const rect of rects) {\r\n            rect.draw(deltaTime)\r\n        }\r\n\r\n        window.requestAnimationFrame(this.draw.bind(this));\r\n    }\r\n\r\n    createPartGrid(x, y) {\r\n        ctx.strokeStyle = 'Black'\r\n        this.drawLine(x, y, x, y + resolution)\r\n        this.drawLine(x, y, x + resolution, y)\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region mouse\r\n    getCursorPositionInPixels(event) {\r\n        const rect = canvas.getBoundingClientRect()\r\n        const x = event.clientX - rect.left\r\n        const y = event.clientY - rect.top\r\n        return {x: x, y: y}\r\n    }\r\n\r\n    getCursorPositionInGrid(event) {\r\n        const pos = this.getCursorPositionInPixels(event)\r\n        return {x: Math.floor(pos.x / resolution), y: Math.floor(pos.y / resolution)}\r\n    }\r\n\r\n    handleMouseDown(e) {\r\n        if (this.busy) return;\r\n\r\n        const cursPos = this.getCursorPositionInGrid(e)\r\n        const {grid} = this.state;\r\n        if (grid[cursPos.y][cursPos.x].isStart) {\r\n            this.setState({isDraggingStart: true})\r\n        } else if (grid[cursPos.y][cursPos.x].isFinish) {\r\n            this.setState({isDraggingFinish: true})\r\n        }\r\n\r\n        this.setState({mouseIsPressed: true});\r\n        mouseStillPressed = true;\r\n    }\r\n\r\n    handleMouseMove(e) {\r\n        if (this.busy) return;\r\n\r\n        // console.log(this.getCursorPosition(e).x + \" | \" + this.getCursorPosition(e).y)\r\n        const pos = this.getCursorPositionInGrid(e);\r\n        if (!this.state.mouseIsPressed) return;\r\n        if (this.state.isDraggingStart) {\r\n            this.moveStartOrFinish(pos.x, pos.y, true)\r\n        } else if (this.state.isDraggingFinish) {\r\n            this.moveStartOrFinish(pos.x, pos.y, false)\r\n        } else {\r\n            this.calculateWall(e);\r\n        }\r\n        mouseStillPressed = false;\r\n    }\r\n\r\n    handleMouseUp(e) {\r\n        if (this.busy) return;\r\n\r\n        this.setState({mouseIsPressed: false, isDraggingStart: false, isDraggingFinish: false});\r\n        if (mouseStillPressed && !this.state.isDraggingStart && !this.state.isDraggingFinish) {\r\n            lastMousePos.x++;\r\n            this.calculateWall(e);\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region dijkstra visual\r\n\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, instant = false) {\r\n        this.clearVisualization(true);\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if (i === 0) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                if (i === visitedNodesInOrder.length - 1) {\r\n                    this.shortPath(nodesInShortestPathOrder, instant);\r\n                } else {\r\n                    const node = visitedNodesInOrder[i];\r\n                    if (speed === \"0\" || instant) {\r\n                        ctx.fillStyle = 'Aqua'\r\n                        this.drawCube(node.col, node.row)\r\n                    } else {\r\n                        let gradient = new Rainbow();\r\n                        gradient.setSpectrum('Yellow', 'Blue', 'Aqua')\r\n                        gradient.setNumberRange(0, 0.6)\r\n                        rects.push(new roundNode(node.col * resolution + 1, node.row * resolution + 1, resolution - 2, resolution - 2, resolution / 1.5, gradient))\r\n                    }\r\n                }\r\n            }, speed * i))\r\n        }\r\n    }\r\n\r\n    shortPath(nodesInShortestPathOrder, instant = false) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if(i===0 || i===nodesInShortestPathOrder.length-1) continue;\r\n            // eslint-disable-next-line no-loop-func\r\n            timeouts.push(setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                if (speed === \"0\" || instant) {\r\n                    ctx.fillStyle = 'Yellow'\r\n                    this.drawCube(node.col, node.row)\r\n                } else {\r\n                    let gradient = new Rainbow();\r\n                    gradient.setSpectrum('Red', 'Yellow')\r\n                    gradient.setNumberRange(0, 0.5)\r\n                    rects.push(new roundNode(node.col * resolution + 1, node.row * resolution + 1, resolution - 2, resolution - 2, resolution / 1.5, gradient))\r\n                }\r\n            }, speed!==\"0\" || instant ? 35 * i : 0));\r\n            timeouts.push(setTimeout(() => {\r\n                this.busy = false;\r\n            }, speed!==\"0\" || instant ? 35*nodesInShortestPathOrder.length : 0))\r\n        }\r\n    }\r\n\r\n    visualize(instant = false) {\r\n        if(this.busy) return;\r\n        this.busy = true;\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        let visitedNodesInOrder;\r\n        let nodesInShortestPathOrder;\r\n\r\n        if(this.algorithm === 0) {\r\n            visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        } else if(this.algorithm === 1) {\r\n            visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrderGreedyBFS(finishNode);\r\n        } else if(this.algorithm === 2) {\r\n            visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\r\n        } else if(this.algorithm === 3) {\r\n\r\n        }\r\n\r\n        this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, instant);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region moving start & finish\r\n\r\n    moveStartOrFinish(x,y,start) {\r\n        let col\r\n        let row\r\n        if(start) {\r\n            col = START_NODE_COL;\r\n            row = START_NODE_ROW;\r\n        } else {\r\n            col = FINISH_NODE_COL;\r\n            row = FINISH_NODE_ROW\r\n        }\r\n        if(lastMousePos.x === x && lastMousePos.y === y) return;\r\n        lastMousePos = {x:x,y:y};\r\n        ctx.clearRect(col*resolution+1, row*resolution+1, resolution-2, resolution-2)\r\n        this.drawStartOrFinish(x,y, start)\r\n        if(this.state.grid[row][col].isWall) {\r\n            const newGrid = this.state.grid.slice()\r\n            newGrid[row][col].isWall = false;\r\n            this.setState({grid: newGrid})\r\n            this.drawWall(col,row)\r\n        }\r\n        if(start) {\r\n            START_NODE_COL = x;\r\n            START_NODE_ROW = y;\r\n        } else {\r\n            FINISH_NODE_COL = x;\r\n            FINISH_NODE_ROW = y;\r\n        }\r\n    }\r\n\r\n    drawStartOrFinish(x,y, start) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[y][x]\r\n\r\n        if(start) {\r\n            newGrid[START_NODE_ROW][START_NODE_COL] = {\r\n                ...newGrid[START_NODE_ROW][START_NODE_COL],\r\n                isStart: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isStart: true,\r\n            };\r\n            ctx.fillStyle = 'Green'\r\n        } else {\r\n            newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = {\r\n                ...newGrid[FINISH_NODE_ROW][FINISH_NODE_COL],\r\n                isFinish: false\r\n            }\r\n            newGrid[y][x] = {\r\n                ...node,\r\n                isFinish: true,\r\n            };\r\n            ctx.fillStyle = 'Red'\r\n        }\r\n        this.drawCube(x, y)\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    //#endregion\r\n\r\n    visualizeMaze() {\r\n        if(this.busy) return;\r\n        this.resetWalls()\r\n        this.clearVisualization()\r\n        this.busy = true;\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        let maze;\r\n        if(this.maze === 0) {\r\n            maze = recursiveDivisionMaze(grid, startNode,finishNode)\r\n        } else if (this.maze === 1) {\r\n            maze = randomMaze(grid,startNode,finishNode)\r\n        }\r\n        if(speed === \"0\") {\r\n            for (const mazeElement of maze) {\r\n                this.drawWall(mazeElement[0], mazeElement[1])\r\n            }\r\n            this.redrawStartAndFinish()\r\n        } else {\r\n            for (let i = 0; i < maze.length; i++) {\r\n                const mazeElement = maze[i]\r\n                timeouts.push(setTimeout(() => this.drawWall(mazeElement[0], mazeElement[1]), speed*i))\r\n\r\n            }\r\n            timeouts.push(setTimeout(() => {this.redrawStartAndFinish(); this.busy = false;}, speed*(maze.length+2)))\r\n        }\r\n    }\r\n\r\n    drawLine(x,y, xd, yd) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x,y)\r\n        ctx.lineTo(xd, yd)\r\n        ctx.stroke();\r\n    }\r\n\r\n    drawCube(col,row) {\r\n        ctx.beginPath();\r\n        ctx.fillRect(col*resolution+1, row*resolution+1, resolution-2, resolution-2)\r\n        ctx.stroke();\r\n    }\r\n\r\n    calculateWall(e) {\r\n        const pos = this.getCursorPositionInGrid(e)\r\n        if(this.state.grid[pos.y][pos.x].isStart || this.state.grid[pos.y][pos.x].isFinish) {\r\n            return;\r\n        }\r\n\r\n        if(lastMousePos.x === pos.x && lastMousePos.y === pos.y) return;\r\n        lastMousePos = pos;\r\n        this.drawWall(pos.x,pos.y)\r\n    }\r\n\r\n    drawWall(x,y) {\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        let widthIn = Math.round(width/resolution)-1\r\n        let heightIn = Math.round(height/resolution)-1\r\n        if(x > widthIn || x < 0 || y > heightIn || y < 0) {\r\n            return;\r\n        }\r\n        const node = newGrid[y][x]\r\n        newGrid[y][x] = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        if(newGrid[y][x].isWall) {\r\n            // ctx.fillStyle = 'Black'\r\n            // this.drawCube(x, y)\r\n            if(speed !== \"0\") {\r\n                let gradient = new Rainbow();\r\n                gradient.setSpectrum('White', 'Black')\r\n                gradient.setNumberRange(0,0.5)\r\n                rects.push(new roundNode(node.col*resolution+1, node.row*resolution+1, resolution-2, resolution-2, resolution/1.5, gradient))\r\n            } else {\r\n                ctx.fillStyle = 'Black'\r\n                this.drawCube(x, y)\r\n            }\r\n        } else {\r\n            ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2,resolution-2)\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    //#region reset\r\n\r\n    clearVisualization(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice()\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(!grid[y][x].isWall && !grid[y][x].isStart && !grid[y][x].isFinish) {\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n                newGrid[y][x].isVisited = false;\r\n                newGrid[y][x].distance = Infinity;\r\n            }\r\n        }\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    redrawStartAndFinish() {\r\n        ctx.fillStyle = 'Green'\r\n        this.drawCube(START_NODE_COL,START_NODE_ROW)\r\n        ctx.fillStyle = 'Red'\r\n        this.drawCube(FINISH_NODE_COL,FINISH_NODE_ROW)\r\n        const newGrid = this.state.grid.slice()\r\n        newGrid[START_NODE_ROW][START_NODE_COL].isWall = false;\r\n        newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isWall = false;\r\n        this.setState({grid: newGrid})\r\n    }\r\n\r\n    resetWalls(skipBusyCheck = false) {\r\n        if(!skipBusyCheck && this.busy) return;\r\n        rects = [];\r\n        const {grid} = this.state;\r\n        const newGrid = grid.slice();\r\n        for (let y = 0; y < grid.length; y++) {\r\n            for (let x = 0; x < grid[y].length; x++) {\r\n                if(grid[y][x].isWall) {\r\n                    newGrid[y][x].isWall = false;\r\n                    ctx.clearRect(x*resolution+1, y*resolution+1, resolution-2, resolution-2)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fullReset() {\r\n        START_NODE_COL = 5;\r\n        START_NODE_ROW = 5;\r\n\r\n        FINISH_NODE_COL = 20\r\n        FINISH_NODE_ROW = 5;\r\n\r\n        this.busy = false;\r\n\r\n        rects = []\r\n        this.setState({ grid: getInitialGrid() });\r\n        ctx.clearRect(0,0,canvas.width, canvas.height)\r\n        this.createGrid()\r\n        for (let i = 0; i < timeouts.length; i++) {\r\n            clearTimeout(timeouts[i]);\r\n        }\r\n        timeouts = []\r\n    }\r\n\r\n    //#endregion\r\n\r\n\r\n    // sliderChanged(id, val) {\r\n    //     if(id===0) {\r\n    //         this.setState({width: val})\r\n    //     } else if(id===1) {\r\n    //         this.setState({height: val})\r\n    //     }\r\n    //     this.reDrawGrid()\r\n    // }\r\n\r\n\r\n    render() {\r\n        // const {width,height} = this.state;\r\n\r\n        return (\r\n            <>\r\n                {/*<div style={{width: 100}}>*/}\r\n                {/*    <div>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={width} tipFormatter={value => `${value}%`} onChange={(val) => this.sliderChanged(0,val)}/>*/}\r\n                {/*        <label>{width}</label>*/}\r\n                {/*    </div>*/}\r\n                {/*    <div style={{height: 10}}/>*/}\r\n                {/*    <>*/}\r\n                {/*        <Slider min={4} max={100} defaultValue={height} onChange={(val) => this.sliderChanged(1,val)}/>*/}\r\n                {/*        <label>{height}</label>*/}\r\n                {/*    </>*/}\r\n                {/*</div>*/}\r\n                <AppBar>\r\n                    <Toolbar>\r\n                        <a href=\"https://github.com/tddebart/better-pathfinding-visualizer\" target=\"_blank\" rel=\"noreferrer\">\r\n                            <img className={\"github\"} src={gitLogo} alt={\"github\"} />\r\n                        </a>\r\n                        <Typography variant=\"h6\" component=\"div\" style={{marginLeft: 10}}>\r\n                            Pathfinding visualizer\r\n                        </Typography>\r\n                        <div className={\"center\"}>\r\n                            {/*Speed control*/}\r\n                            <FormControl variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                                <InputLabel id=\"demo-simple-select-label\">Speeds</InputLabel>\r\n                                <Select id={\"speed\"} defaultValue={\"5\"} style={{textAlign: 'center'}} onChange={(event) => {\r\n                                    speed = event.target.value;\r\n                                }}>\r\n                                    <MenuItem value=\"80\">Slow</MenuItem>\r\n                                    <MenuItem value=\"30\">Fast</MenuItem>\r\n                                    <MenuItem value=\"15\">Faster</MenuItem>\r\n                                    <MenuItem value=\"5\">Extra Fast</MenuItem>\r\n                                    <MenuItem value=\"0\">Instant</MenuItem>\r\n                                </Select>\r\n                            </FormControl>\r\n                            <FormControl className={\"customSelect\"} variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                                <InputLabel id=\"demo-simple-select-label\">Algorithms</InputLabel>\r\n                                <Select\r\n                                    labelId=\"demo-simple-select-label\"\r\n                                    id=\"demo-simple-select\"\r\n                                    label=\"Algorithms\"\r\n                                    defaultValue={0}\r\n                                    onChange={(event) => {\r\n                                        this.algorithm = event.target.value;\r\n                                    }}\r\n                                >\r\n                                    <MenuItem value={0}>Dijkstra algorithm</MenuItem>\r\n                                    <MenuItem value={1}>A* algorithm</MenuItem>\r\n                                    <MenuItem value={2}>Greedy best first search</MenuItem>\r\n                                </Select>\r\n                            </FormControl>\r\n                            <ButtonGroup variant=\"contained\" className=\"buttonDown\">\r\n                                <Button onClick={() => this.visualize()}>Visualize</Button>\r\n                                <Button onClick={() => this.fullReset()}>Reset</Button>\r\n                                <Button onClick={() => this.resetWalls()}>Clear walls</Button>\r\n                                <Button onClick={() => this.clearVisualization()}>Clear path</Button>\r\n                            </ButtonGroup>\r\n\r\n                            <FormControl className={\"customSelect\"} variant={'standard'} sx={{ m: 1, minWidth: 80 }}>\r\n                                <InputLabel id=\"demo-simple-select-label\">Maze's</InputLabel>\r\n                                <Select\r\n                                    labelId=\"demo-simple-select-label\"\r\n                                    id=\"demo-simple-select\"\r\n                                    label=\"Maze's\"\r\n                                    defaultValue={0}\r\n                                    onChange={(event) => {\r\n                                        this.maze = event.target.value;\r\n                                    }}\r\n                                >\r\n                                    <MenuItem value={0}>Recursive division</MenuItem>\r\n                                    <MenuItem value={1}>Random</MenuItem>\r\n                                </Select>\r\n                            </FormControl>\r\n                            <ButtonGroup variant={\"contained\"} className=\"buttonDown\">\r\n                               <Button onClick={() => this.visualizeMaze()}>Generate maze</Button>\r\n                            </ButtonGroup>\r\n                        </div>\r\n                    </Toolbar>\r\n                </AppBar>\r\n                <canvas\r\n                    id={\"canvas\"}\r\n                    // onClick={(e) =>  this.calculateWall(e)}\r\n                    onMouseDown={(e) => this.handleMouseDown(e)}\r\n                    onMouseMove={(e) =>\r\n                        this.handleMouseMove(e)\r\n                    }\r\n                    onMouseUp={(e) => this.handleMouseUp(e)}\r\n                />\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        prevNode: null,\r\n    }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = []\r\n    for (let row = 0; row < height/resolution; row++) {\r\n        const currentRow = []\r\n        for (let col = 0; col < width/resolution; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};","export function randomMaze(grid, startNode, finishNode) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let walls = [];\r\n    for (let row = 0; row < grid[0].length; row++) {\r\n        for (let col = 0; col < grid.length; col++) {\r\n            if (\r\n                (row === startNode.row && col === startNode.col) ||\r\n                (row === finishNode.row && col === finishNode.col)\r\n            )\r\n                continue;\r\n            if (Math.random() < 0.33) {\r\n                walls.push([row, col]);\r\n            }\r\n        }\r\n    }\r\n    // walls.sort(() => Math.random() - 0.25);\r\n    return walls;\r\n}","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyRTk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNTE3OEEyRjk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJDOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJEOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+FYrpWAAABrNJREFUeNrkW2ls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\"","import React from 'react';\nimport './App.css';\nimport Visualizer from \"./Visualizer/visualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n          <Visualizer/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","\n\nconst reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}